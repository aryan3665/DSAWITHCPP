====================================================================
|                  BINARY SEARCH - COMPLETE GUIDE                  |
|                    (Hinglish Explanation)                         |
====================================================================

1. Binary Search Kya Hai?  
----------------------------------------  
Binary Search ek fast searching algorithm hai jo SORTED arrays/lists par kaam karta hai.  
- Yeh repeatedly array ko aadha (half) karke search space ko reduce karta hai.  
- Time Complexity: O(log n) â†’ Bahut efficient!  

2. Real-World Example (Phonebook Example)  
----------------------------------------  
Maano hume ek phonebook mein "Rahul" naam dhundhna hai:  
- Phonebook A-Z sorted order mein hai.  
- Hum middle page kholte hain, maano "M" par.  
- "Rahul", "M" ke baad aata hai (R > M), toh hum right half mein search karenge.  
- Repeat until "Rahul" mil jaaye ya pata chale ki naam exist nahi karta.  

3. Conditions for Binary Search  
----------------------------------------  
- Array SORTED hona chahiye (Ascending/Descending).  
- Elements comparable hone chahiye (Numbers, Strings, etc.).  

4. Binary Search Approaches  
----------------------------------------  
(A) Iterative Approach (Loops use karke)  
(B) Recursive Approach (Function khud ko call karega)  

5. Iterative Binary Search (Code + Explanation)  
----------------------------------------  
def binary_search_iterative(arr, target):  
    low = 0  
    high = len(arr) - 1  

    while low <= high:  
        mid = (low + high) // 2  # Middle index nikalo  
        if arr[mid] == target:  
            return mid          # Mil gaya!  
        elif arr[mid] < target:  
            low = mid + 1       # Right half mein search  
        else:  
            high = mid - 1      # Left half mein search  
    return -1  # Target nahi mila  

Example Usage:  
arr = [2, 5, 8, 12, 16, 23, 38]  
target = 16  
print(binary_search_iterative(arr, target))  # Output: 4 (index)  

6. Recursive Binary Search (Code + Explanation)  
----------------------------------------  
def binary_search_recursive(arr, target, low, high):  
    if low > high:  
        return -1  # Base case: target nahi mila  

    mid = (low + high) // 2  
    if arr[mid] == target:  
        return mid  
    elif arr[mid] < target:  
        return binary_search_recursive(arr, target, mid + 1, high)  # Right half  
    else:  
        return binary_search_recursive(arr, target, low, mid - 1)    # Left half  

Example Usage:  
arr = [2, 5, 8, 12, 16, 23, 38]  
target = 23  
print(binary_search_recursive(arr, target, 0, len(arr)-1))  # Output: 5  

7. Time Complexity Analysis  
----------------------------------------  
- Best Case: O(1) â†’ Element middle mein hi mil gaya.  
- Worst Case: O(log n) â†’ Har step mein array half ho raha hai.  
- Space Complexity:  
  - Iterative: O(1) â†’ Constant extra space.  
  - Recursive: O(log n) â†’ Call stack ke liye (har recursive call memory leti hai).  

8. Binary Search vs Linear Search  
----------------------------------------  
| Feature         | Binary Search  | Linear Search  |  
|-----------------|----------------|----------------|  
| Time Complexity | O(log n)       | O(n)           |  
| Sorted Required | YES            | NO             |  
| Efficiency      | Fast           | Slow           |  

9. Common Mistakes & Tips  
----------------------------------------  
- Array sorted nahi hai â†’ Binary Search fail hoga.  
- `low <= high` (equal sign bhoolna nahi).  
- Integer Overflow: `mid = low + (high - low)//2` better hai.  

10. Applications (Real-World Uses)  
----------------------------------------  
- Dictionary/Phonebook mein shabd dhundhna.  
- Database sorted records ke liye.  
- Game guesses (Higher/Lower) mein use hota hai.  

====================================================================
|              THANKS FOR LEARNING BINARY SEARCH!                   |
====================================================================










------>lower and upper bound

## ðŸ”¹ Concept

* **Lower Bound**:
  Sorted array me **wo index jaha pehle baar `x` ya usse bada element milta hai**.
  (Matlab `>= x` ka first position).

* **Upper Bound**:
  Sorted array me **wo index jaha pehle baar `x` se bada element milta hai**.
  (Matlab `> x` ka first position).

---

## ðŸ”¹ C++ Code (Binary Search se)

```cpp
#include <bits/stdc++.h>
using namespace std;

// LOWER BOUND FUNCTION
int lowerBound(vector<int>& arr, int x) {
    int n = arr.size();
    int low = 0, high = n - 1;
    int ans = n;  // default: agar element nahi mila toh n return hoga

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] >= x) {
            ans = mid;       // potential answer
            high = mid - 1;  // left me aur dekhna hai
        } else {
            low = mid + 1;   // right side move
        }
    }
    return ans;
}

// UPPER BOUND FUNCTION
int upperBound(vector<int>& arr, int x) {
    int n = arr.size();
    int low = 0, high = n - 1;
    int ans = n;  // default: agar bada element nahi mila toh n return hoga

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] > x) {
            ans = mid;       // potential answer
            high = mid - 1;  // left me aur dekhna hai
        } else {
            low = mid + 1;   // right side move
        }
    }
    return ans;
}

int main() {
    vector<int> arr = {1, 2, 4, 4, 5, 7, 9};

    int x = 4;
    cout << "Lower Bound of " << x << " = " << lowerBound(arr, x) << endl;
    cout << "Upper Bound of " << x << " = " << upperBound(arr, x) << endl;

    return 0;
}
```

---

## ðŸ”¹ Explanation (Hinglish)

* `lowerBound(arr, 4)` return karega **2** kyunki `arr[2] = 4` (first `>= 4`).
* `upperBound(arr, 4)` return karega **4** kyunki `arr[4] = 5` (first `> 4`).

---

ðŸ‘‰ Matlab simple hai:

* **lower\_bound â†’ pehla index jaha value `x` ya usse badi mile**
* **upper\_bound â†’ pehla index jaha value strictly `x` se badi mile**

---









