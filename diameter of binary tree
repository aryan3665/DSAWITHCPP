Binary Tree Diameter Explanation
===============================

1. Basic Concept 
--------------------------------
- Binary tree ka diameter = sabse lamba path jisme edge count ki jati hai
- Path kisi bhi do nodes ke beech ho sakta hai:
  * Root se hokar ja sakta hai
  * Pure left subtree mein ho sakta hai
  * Pure right subtree mein ho sakta hai

2. Key Observations 
---------------------------------
- Diameter = Maximum of:
  * Left subtree ka diameter
  * Right subtree ka diameter
  * (Left height + Right height) of current node

3. Optimal Approach 
----------------------------------
- Ek hi traversal mein height aur diameter calculate karenge
- Har node pe:
  * Left aur right subtree ki height nikalege
  * Current diameter = leftHeight + rightHeight
  * Global maximum update karenge
  * Return karenge current node ki height

4. Dry Run (Step-by-Step Chalana)
--------------------------------
Example Tree:
      1
     / \
    2   3
   / \    
  4   5    

Calculations:
1. Node 4: height=1, diameter=0
2. Node 5: height=1, diameter=0 
3. Node 2: height=2, diameter=2 (4-2-5)
4. Node 3: height=1, diameter=0
5. Node 1: height=3, diameter=3 (4-2-1-3 or 5-2-1-3)

Final Diameter: 3

5. C++ Implementation 
--------------------------
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node *left, *right;
    Node(int val) : data(val), left(NULL), right(NULL) {}
};

int height(Node* root, int &diameter) {
    if(!root) return 0;
    
    int leftH = height(root->left, diameter);
    int rightH = height(root->right, diameter);
    
    diameter = max(diameter, leftH + rightH);
    return 1 + max(leftH, rightH);
}

int diameterOfBinaryTree(Node* root) {
    int diameter = 0;
    height(root, diameter);
    return diameter;
}

int main() {
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->left->right = new Node(5);
    
    cout << "Diameter: " << diameterOfBinaryTree(root);
    return 0;
}

6. Complexity Analysis 
-------------------------------
- Time Complexity: O(n) - har node ek baar visit hoti hai
- Space Complexity: O(h) - recursion stack, worst case O(n)

7. Edge Cases 
------------------------------
- Empty tree (return 0)
- Single node tree (diameter = 0)
- Left/Right skewed tree
- Full balanced tree

8. Variations 
----------------------
- Nodes count karna ho to: diameter = leftH + rightH + 1
- Weighted tree: edge weights ka sum consider karna
- N-ary trees: saare children ke liye calculate karna

9. Practice Problems (AbhyÄs)
----------------------------
1. Find diameter:
       1
      / \
     2   3
    / \   \
   4   5   6
      / \   \
     7   8   9
   Answer: 5 (7-5-2-1-3-6-9)

2. Count nodes instead of edges



10. Applications (Upayog)
------------------------
- Network routing paths
- File system directory structures
- Game decision trees
- Organizational hierarchy analysis

12. Conclusion (Antim Nishchay)
------------------------------
Ye problem binary trees ki fundamental understanding ke liye bahut important hai. Isme:
- Tree traversal
- Height calculation
- Recursive thinking
- Optimization techniques
sab cover hote hain.
